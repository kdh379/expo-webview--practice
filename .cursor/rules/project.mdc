---
description: 코드 작성 규칙
globs: 
alwaysApply: true
---
# Expo WebView 브릿지 프로젝트 가이드

## 개요

이 프로젝트는 Expo와 WebView를 이용한 네이티브-웹 브릿지 통신 구현 프로젝트입니다. 웹 애플리케이션에서 네이티브 기능을 사용할 수 있도록 브릿지 인터페이스를 제공합니다.

## 브릿지 아키텍처 이해하기

### 통신 흐름
1. **웹 → 네이티브 요청**: 웹에서 `bridge.xxx()` 메서드 호출 → `postMessage()`를 통해 네이티브로 전송
2. **네이티브 처리**: `useMessageHandler` 훅이 메시지 타입에 따라 적절한 핸들러 호출
3. **네이티브 → 웹 응답**: 처리 결과를 웹으로 전송 → 웹에서 Promise 형태로 결과 수신

### 핵심 컴포넌트
- **WebViewBridge**: 웹뷰 컴포넌트와 메시지 핸들링 로직 통합
- **NativeScreenManager**: 모달 화면(카메라, OCR 등) 관리
- **useMessageHandler**: 브릿지 메시지 처리 로직 구현
- **handlers/**: 각 기능별 핸들러 구현

## 코드 작성 규칙

### 일반 원칙
- **타입 안전성**: TypeScript 타입 활용, any 타입 지양
- **에러 처리**: try-catch 패턴 사용, 사용자 친화적 에러 메시지 제공
- **상태 관리**: 관련 상태는 객체로 그룹화하여 관리
- **코드 분리**: 기능별로 파일 분리, 단일 책임 원칙 준수

### 컴포넌트 작성
```typescript
// 컴포넌트는 함수형으로 작성
// Props 타입은 별도로 정의
// 스타일은 컴포넌트 파일 하단에 정의
interface Props {
  title: string;
  onPress?: () => void;
}

export function MyComponent({ title, onPress }: Props) {
  return (
    // ...
  );
}

const styles = StyleSheet.create({
  // ...
});
```

### 브릿지 핸들러 작성
```typescript
// 각 핸들러는 createXXXHandlers() 형태의 함수로 구현
// MessageHandlers 타입의 일부를 반환하도록 구현
// 에러 처리는 try-catch로 구현
import type { MessageHandlers } from "../hooks/useMessageHandler";

const createFeatureHandlers = (): Pick<MessageHandlers, "FEATURE_ACTION1" | "FEATURE_ACTION2"> => ({
  FEATURE_ACTION1: async (id, payload) => {
    try {
      // 구현...
      return { id, success: true, data: result };
    } catch (error) {
      console.error("Feature error:", error);
      return { id, success: false, error: "사용자 친화적 에러 메시지" };
    }
  },
  
  // 다른 핸들러...
});

export default createFeatureHandlers;
```

### 브릿지 타입 정의
```typescript
// types/bridge.d.ts에 메시지 타입 추가
// 각 기능별 상세 타입은 types/xxx.d.ts 파일에 정의
// 타입은 전역 타입으로 정의 (export 없이)

// types/bridge.d.ts
type MessageTypes = {
  // 기존 타입들...
  FEATURE_ACTION1: FeatureOptions;
  FEATURE_ACTION2: undefined;
};

// types/feature.d.ts
interface FeatureOptions {
  param1?: string;
  param2?: number;
}
```

## 네이밍 컨벤션

- **컴포넌트**: PascalCase (예: `FeatureComponent`)
- **함수/변수**: camelCase (예: `handleFeature`)
- **상수**: UPPER_SNAKE_CASE (예: `MAX_RETRY_COUNT`)
- **타입/인터페이스**: PascalCase (예: `FeatureOptions`)
- **브릿지 메시지 타입**: UPPER_SNAKE_CASE (예: `FEATURE_ACTION`)
  - 형식: `기능_명령_타입` (예: `CAMERA_TAKE_PICTURE`, `OCR_SCAN_ID_CARD`)
- **파일명**:
  - 핸들러 파일: xxxHandler.ts (예: `featureHandler.ts`)
  - 타입 정의 파일: xxx.d.ts (예: `feature.d.ts`)

## 새로운 브릿지 기능 추가 방법

새로운 브릿지 기능을 추가할 때는 다음 단계를 따르세요:

1. **타입 정의**:
   - `types/bridge.d.ts`에 메시지 타입 추가
   - 필요시 `types/xxx.d.ts`에 상세 타입 정의

2. **핸들러 구현**:
   - `components/webview/handlers/xxxHandler.ts` 파일 생성
   - `createXXXHandlers()` 함수 구현
   - 적절한 에러 처리 포함

3. **핸들러 등록**:
   - `components/webview/handlers/index.ts`에 핸들러 추가

4. **웹 API 구현**:
   - `react-example/lib/bridge.ts`에 웹측 API 구현

## 코드 리뷰 체크리스트

- [ ] 타입 안전성: 적절한 타입 정의와 사용
- [ ] 에러 처리: 모든 예외 상황 처리
- [ ] 네이밍: 컨벤션 준수
- [ ] 코드 구조: 적절한 파일 분리와 책임 분배
- [ ] 성능: 불필요한 렌더링이나 계산 방지
- [ ] 테스트 가능성: 테스트하기 쉬운 구조

## 디버깅 팁

- Expo 개발 서버 로그 확인
- 웹뷰 내 `console.log` 출력 확인
- React DevTools 사용
- 브릿지 통신 오류 시 웹뷰 콘솔 로그와 메시지 형식 검증

## 알려진 제한사항

- Expo GO에서는 일부 네이티브 기능(블루투스 등) 사용 제한
- 실제 기기에서 테스트 권장 (시뮬레이터에서는 일부 기능 제한)
- 웹뷰 디버깅은 Chrome 개발자 도구 활용